# 実行器デザイン

## この文書について

実行エンジン内、Executor APIを提供する実行器のデザインについて述べる
本文書では実行器の内部設計方針やトピックに関して記述し、スケジューラー(DAGコントローラ)からの視点については別文書(scheduler_design.md)を前提とする。

## 設計方針

ステップグラフの実行ではShuffleのような待ち合わせを行うブロッキング処理とForwardのような漸時実行可能なインクリメンタル処理が混在するが、ブロッキング処理とインクリメンタル処理を共通APIでサポートし、かつインクリメンタル処理のレイテンシーに影響を与えない設計を追求する
将来的な拡張の余地をもたせるため、状態管理はDAGコントローラーで行い、状態の進行には常にDAGコントローラーが介入するものとする。

## デザイントピック

下記にトピックを列挙する

### ブロッキングエクスチェンジとインクリメンタルエクスチェンジ

エクスチェンジはブロッキングとインクリメンタルなものの2つに分かれる。Shullfeはブロッキング、Forwardはインクリメンタルである。Broadcastはどちらでも処理が可能であるが、以下ではとりあえずBroadcastもインクリメンタルなものとして扱う。
ステップグラフの実行においては、順次上流ステップがCOMPLETEDになった後に下流ステップを開始させるという動作を基本とする。ただしインクリメンタルなエクスチェンジでは、そのSink経由で上流からのデータ到達を検知し、エクスチェンジとその下流のステップにイベント(upstream providing)を生成してステップのRUNNINNG開始をトリガーする。この方法により上流ステップが実行中にも結果を随時下流のステップへ渡して上流と下流が並行して動作可能になる。

下記チャートで例を示す：
https://docs.google.com/presentation/d/1x45LtUf1YmCOOV5v2kFaIyejCHaaPzB_AFi72x84CC4/edit#slide=id.g6eb6ab093e_0_378

イベントによる状態遷移詳細については別文書(event_details.md)を参照のこと。

### パーティション数

プロセスは並列で実行することが期待されている。タスクを作成するためにパーティション数が必要となる。パーティション数は下記のルールに基づいて決められる。

1. SQLリクエストごとにデフォルトパーティション数が決まっており、制限がなければプロセスはそのパーティション数で稼働する。ただし下記の制限によりデフォルトを採用できないこともある。
1. exchangeの出力ポートに複数の下流プロセスが接続されている場合、下流プロセス同士は同一パーティション数である
1. limitを行うForwardの入力ポートには単一の上流プロセスのみ接続され、かつそのパーティション数は1である
1. shuffleは下流のプロセスのパーティション数を仮定して処理を行うがshuffleの結果パーティションにデータが供給されない場合がある。その際は供給されないパーティションを除去したパーティション数で下流プロセスを稼働する。ただし例外的に下流プロセスがtake_cogroupを含む場合は最初に仮定したパーティション数で稼働する(データが生成されなかったパーティションにも意味があるため)。
1. broadcastは下流のプロセスに影響を与えない。ただし副タスクは常に副入力ポートに対して1:1で作成され、副入力は1つのパーティションとして処理される。
1. forwardの下流プロセスのパーティション数は上流プロセスのパーティション数の和とする。ただし例外的に上流プロセスの一つがscanを含む場合は複数パーティションへの分散を図るためにこの制限を受けないものとする。(TBD: 明示的に指示された方がいいか)

このうち4以外のルールだけであればパーティションは実行前に全て決められる。4の条件のため、パーティション数はステップグラフの実行の進捗につれて上流から下流に決定していく。

### ステップの主タスクが漸時作られるケース

ブロッキングエクスチェンジ下流のプロセスはエクスチェンジがCOMPLETEDになってからタスクを開始するため、プロセスのRUNNING遷移時にそのプロセスが必要とする全ての主入力タスクが作成される。
一方インクリメンタルなエクスチェンジの場合はエクスチェンジ上流のステップが部分的にRUNNINGでデータを供給すればエクスチェンジ及び下流のプロセスは開始できる。
そのため、RUNNING遷移時はタスクが部分的にしか作成されていない可能性がある。このケースも上記upstream providingイベントにてカバーされる。

https://docs.google.com/presentation/d/1V25AEmJy9Zq3cEdbhdFc7uqgWpJI_gGd8O-9FJBv338/edit#slide=id.g6eb6ab093e_0_373

### Forward exchangeによるLimitの実現
Forwardエクスチェンジによる行数制限は下記の方法により実現する
- 行数制限機能付きForwardエクスチェンジへの入力は1つのプロセスに限定する
- sinkへのwriteをカウントし、制限を超えたらcompletion instructedイベントによってそのステップの早期終了をdagコントローラーに通知する
- DAGコントローラーはcompletion instructedイベントを受けてステップのタスクの早期終了をタスクスケジューラーに要求する
- DAGコントローラーは下流がCOMPLETEDなステップは処理する必要がないと判断し、上と同様に早期終了をタスクスケジューラーに要求する。この処理は適当なステップ(例えばShuffle)まで上流方向へ伝搬する。
- タスクが終了し、入力ポートがcompletedであればCOMPLETEDになるのは通常の終了処理と同様
- ただし、上記で早期終了しようとしているプロセスにemit, insert, update, delete演算子が含まれる場合は下流のステップを見るだけでは終了していいかの判断がつかない。そこで、仮想的にそれらの演算子を持つプロセスは下流に特殊なエクスチェンジ(Deliver)を持つという事で対応する

### レーンの概念
ステップの処理が複数あったとき、処理内容によってはそれらを同時には行えないという制限があることがある。例えばトランザクションエンジンの仕様により、同一トランザクションでのread/write処理を異なるスレッドから同時にリクエストしてはいけない、など。これをうまく扱うために、タスクスケジューラーは「レーン」の概念を持ち、そのレーン向けのタスクは同時に1つしか実行しないものとする。
タスクにはany(どのレーンでも実行可)かsome(あるレーンでのみ実行可)という属性が与えられて実行が指示される。
現状トランザクションエンジンは上記の制約があるので、scanやinsert/update/deleteを含むプロセスはsome指定でタスクを生成する。