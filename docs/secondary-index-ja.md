# セカンダリインデックス設計

2021-01-27 arakawa

2022-07-27 kurosawa 設計文書として更新

## この文書について

* この文書では、tsurugi OLTPにおけるセカンダリインデックス (以下、単にインデックスとかく) の設計を示す

## 基本的な設計方針

* ストレージ層 (sharksfin~shirakami) 側にインデックス向けの特別な機能を用意しない
  * インデックスは通常のテーブルと同様の方法で取り扱う
    * テーブルと同様にトランザクションの一部として read/write を行い、永続化処理を行う
    * テーブルと同様に mass-tree インデックス上で管理される
  * ストレージ層でインデックスの構築を行わない
    * ストレージ層からはテーブルとインデックスは同等であり、インデックスの構築はより上位の層で行う
    * これに関連し、ストレージ層はテーブルやインデックスのスキーマを感知しない
* インデックスの更新は、SQL実行エンジン (jogasaki) が行う
  * テーブルデータの更新と同時にインデックスを更新する
    * テーブルデータとインデックスは同一のトランザクションで更新する
* 上記を TPC-C による検証と並行して、検討及び必要な個所の実装を行う

## インデックスの格納形式

* インデックスの各エントリをストレージ層に格納する際、以下のように取り扱う
  * キーは、そのインデックスのキーと主キーを順に連接したものを利用する
    * 主キー以外に行を識別する値がある場合、そちらを利用してもよい
    * ただし、インデックスキーは特定の列が降順 (`DESC`) に並んでいることを期待する場合もある
    * 当然ながら、これらの値はキーとしてエンコードされている必要がある
  * 値は、テーブルと同様に（一部の）列の値を保持する
    * これは、 index only scan を実現するために追加された列の値を含める (`CREATE INDEX ... INCLUDES ...`)
    * そのような列が一つも存在しない場合、値は空でもよい
    * こちらの値については、エンコード方式についての制約は特にない（が、テーブルと同様にするのが無難であろう）
* 各インデックスエントリは、インデックス上のキーが衝突してもかならずストレージ上のキーがユニークであることが保証される
  * これは、常にストレージ上のキーの末尾に、当該行の主キーが含まれるためである
  * この構造は、たとえインデックスが unique index であっても同様に扱う (**当面の措置**)
    * unique index の取り扱いの問題が主
  * 上記の方針により、セカンダリインデックスは `::yugawara::storage::index_feature::unique` が常に無効である
    * 上記が無効である場合、キーのすべての値が特定されている場合であっても、SQL実行エンジンは演算 `::takatori::relation::find` 等において、それらの値の列を接頭辞とした範囲検索を行わなければならない
    * 逆に言えば、上記の値によって接頭辞による探索を行うかどうか判断すべきで、インデックスがプライマリ/セカンダリであることは重要でない

## 付録：将来的な検討項目

* 本設計は、基本的に実行時性能を犠牲にして様々な問題を簡単にしている
* このため、上記方式でインデックスを実現したのち、いくつかの性能を確認して今後の方針を検討する必要がある
  * (a) 書き込み性能
    * トランザクション内でインデックスの更新を行うため、インデックスが多い、または複雑なインデックスが存在する場合に書き込み性能の低下が懸念される
  * (b) 永続化性能
    * インデックスを永続化する方式のため、インデックスが多い場合に書き込み性能の低下が懸念される
    * 同様に、ログ等からインデックスを復元する際に、I/O負荷の増大が懸念される
* 以下は、アーキテクチャがとりうる各種選択肢である
  * (1) そもそも誰がインデックスの構築を行うのか
    * (1-a) SQL実行エンジン
      * SQL実行エンジンがテーブルにデータを書き込む際に、ついでにインデックスにも書き込む
      * ナイーブだが細かく制御でき、確実に実現可能
      * 最適化の余地が少なく、例えば更新の遅延等はこの方式では厳しい
    * (1-b) ストレージ層
      * ストレージエンジンがデータを書き込む際に、ついでにインデックスにも書き込む
      * 現在はストレージエンジンがスキーマ情報を有していないため、別途その通達が必要になる
      * インデックスの更新をブラックボックス化できるため、最適化の余地が大きい
    * (1-c) 新たな中間層 (exec/cc)
      * 折衷案で、上記両者の隙間にインデックス更新のための層を挟む
      * 問題の分割ができ、統計情報の作成等も仕込みやすくはなるが、細かな制御と最適化の余地はいずれも悪いところだけ引き継ぐ可能性がある
  * (2) セカンダリインデックス（またはその変更ログ）はそもそも durable にするのか
    * (2-a) durable にする
      * durable にすることで、他のテーブルと同様に扱えることになる
      * 取り回しはよくなるが、write 性能に影響が出ることが予想され、遅延更新の余地がほぼなくなる
    * (2-b) durable にしない
      * テーブルデータからインデックスを再構築する必要がある
      * ストレージ層はスキーマ情報を知らないため、実際の更新はより上位の層に移譲するか、または当該情報をストレージ層が知る必要がある
      * テーブルイメージのようなものをインデックスに対して構築できないことになるので、場合によっては性能的に不利
  * (3) インデックスエントリをCCにおけるページとして扱うか
    * (3-a) インデックスをテーブルと同じ格にして、インデックスエントリも独立したページとして取り扱う
      * テーブルへの write はすべてのインデックスへの write になる (tx内でインデックス更新する場合) が、インデックスへの read がテーブルへの read とならないケースがある
      * 思考停止してすぐに取り掛かれるのがこっちだが、write preserved 方式と相性が悪い印象がある
      * インデックスの数分だけ write 性能が落ちるので、どのくらいの影響になりうるかは勘所を知る必要がある
    * (3-b) インデックスを単なる補助データ構造とみなし、テーブル上のページを中心に CC を行う
      * インデックスへの read はテーブル上の当該ページを read したということにして、インデックスエントリを CC におけるページとは別物として扱う
      * インデックスの更新を遅延させる余地が生まれるが、そもそも難しいうえに当初の phantom avoidance の問題を別途解決する必要がある
        * インデックスは論理的にはテーブルビューに近い概念なので、実際には次のトランザクションが読むまでに準備できていればいい (これはあらゆるデータに言える話ではあるが)
  * (4) どうやって統計情報を作成するのか (余談)
    * (4-a) 定期的にテーブルデータから作成する
      * 暇なときにテーブルをサンプリングして統計情報を構築する
      * サンプリングを行うのは通常の CC と別口で行う必要はあるが、うまく read only snapshot 的なものを読めれば、CCのスケジューラに大きな負担をかけずにやれる余地がある
      * おそらく、他の方法をとってもこのパスは必要になる
    * (4-b) ログを別途分析する
      * 出力した CC のログを読み込んで統計情報を構築する
      * 構成的に疎結合にできる可能性はあるのと、全体アーキ上のパーツを使う余地はあるが、微妙に迂遠な感じはする
    * (4-c) 更新と同時に行う
      * テーブルへの書き込み時に統計情報を併せて更新する
      * CC 側と独立して統計情報を作れるが、SQL実行エンジンは更新部分の情報しか持ち合わせていないため、裏に何らかの統計処理のための機構が必要
