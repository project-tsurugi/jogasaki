# SQLによるインデックスへのスキャン・挿入操作

2022-12-08 kurosawa

## この文書について

phantomの発生可能性の分析のために、SQLがスキャンや挿入操作を実行するかという判断が必要になるので、その判定方法について記述する

## 前提

- SQLの表は1個のプライマリインデックスと0個以上のセカンダリインデックスからなる
  - プライマリインデックスは表と同じ名前をもつ
  - セカンダリインデックスはCREATE INDEX文で定義された名前(built-in表の場合は内部で定義された名前)をもつ

- 下記2条件の両方を満たした場合、CCエンジンの判定によってファントム発生と判断されることがある
  - あるトランザクションがインデックス(プライマリ、またはセカンダリ)に対してスキャンを実行している
  - 別のトランザクションが上でスキャンされたものと同じインデックスへレコードの挿入を行っている

- 本文書では上記2条件をSQLとその実行計画から判定するための情報を記述する
  - CCエンジンの判定については本文書の対象外

- 現状(2022-12)のSQL実行エンジン実装を前提としており、変化する可能性がある。特にスキャンを実行する演算子は増える可能性がある。

## SQLによってスキャンが行われる条件

### プライマリインデックスへのスキャン

下記の条件を全て満たすときにプライマリインデックスへのスキャンが実行される
- 実行計画が下記の演算子のいずれかを含む(*1)
  - scan
- 上記演算子の対象がプライマリインデックスである(*2)

### セカンダリインデックスへのスキャン

下記の条件を全て満たすときにセカンダリインデックスへのスキャンが実行される
- 実行計画が下記の演算子のいずれかを含む(*1)
  - scan
  - find
  - join_find
- 上記演算子の対象がセカンダリインデックスである(*2)

## インデックスへの新規レコードの挿入操作

ファントム発生のもう一つの条件である、インデックスへのレコード挿入操作について述べる
ここでのレコード挿入はインデックスに存在しないレコードを新規に追加することを指し、SQLのINSERT文だけでなくUPDATE文でも発生することがある。

### INSERT文

表へのINSERT文が成功し、1行以上のレコードが追加された場合
- プライマリインデックスへのレコード挿入になる
- セカンダリインデックスが存在する場合、セカンダリインデックスへのレコード挿入になる

### UPDATE文

表へのUPDATE文が成功した場合、UPDATE文の前後の値の変化によって挿入になる場合とそうでない場合がある

プライマリインデックス
- UPDATE文が主キー列の一部または全部を更新対象としていて、それらの列の値が一部でも変化する場合、プライマリインデックスへの挿入になる
- 主キー列を更新対象としていても、それらの列の値が変化しない場合、プライマリインデックスへの挿入にはならない
- 主キー列を更新対象にしていない場合、プライマリインデックスへの挿入は発生しない

セカンダリインデックス(存在する場合)
- 主キー列とセカンダリインデックスの索引列からなる列のセットの一部または全部を更新対象としていて、それらの列の値が一部でも変化する場合、セカンダリインデックスへの挿入になる
- 主キー列・索引列を更新対象としていても、それらの列の値が変化しない場合、セカンダリインデックスへの挿入にはならない
- 主キー列・索引列を更新対象にしていない場合、セカンダリインデックスへの挿入は発生しない

### 表へのDELETE文の実行

プライマリインデックス、セカンダリインデックスともにレコード挿入は起こらない

## 注

- スキャンが起こるのはクエリだけとは限らずDELETE文やUPDATE文でもWHERE処理にともなうスキャンが発生し得る

- (*1) tanzawaのexplain出力ではscanという単語が複数の箇所に現れるが、()の内部に現れる方が本文書でいう演算子名である。下の例で演算子名はfindであり、scanではない。

  ```
  1. scan (find) {source: index, table: TSECONDARY, index: TSECONDARY_I1, access: point}
  ```

- (*2) tanzawaのexplain出力ではセカンダリを対象にしている場合は `source: index`, プライマリを対象にしている場合は `source: table`のように表示される模様

