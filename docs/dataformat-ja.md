# リレーショナルデータ保存形式

version: 1 (umikongo)

version: 2 (2020-11 kurosawa jogasaki用に修正)

## この文書について

* sharksfin を利用してリレーショナルデータを格納するためのデータフォーマットを規定する

## 制約

* キーの大小関係
  * `NULL` は常に他のあらゆる値よりも小さい
* テーブル
  * 主キーを構成する属性は、いずれかが非 `NULL` の値でなければならない
* インデックス
  * インデックスキーを構成する属性がすべて `NULL` となるような行は、インデックスに登録されない
* ストレージ
  * キーは固定長または可変長
  * ペイロードは可変長
  * キーに対してペイロードは1個または2個以上
  * キーは `unsigned char[]` の辞書式順序に整列

## データ形式

### テーブル(プライマリインデックス)

* キー
  * 主キーの各属性をキーエンコーディングによってバイト列に変換したものを格納
* ペイロード
  * 主キーを除いたテーブル属性をペイロードエンコーディングによってバイト列に変換したものを格納

### インデックス(セカンダリインデックス)

* キー
  * インデックスキーと主キーの各属性をそれぞれキーエンコーディングし、インデックスキー、主キーの順て連接したバイト列
* ペイロード
  * セカンダリインデックスが特定の列の値を保持する場合(e.g. CREATE INDEX ... INCLUDE ...)、その列に対応する属性をペイロードエンコーディングによってバイト列に変換し連接したものを格納
  * 上記以外の場合、ペイロードは空

## キーエンコーディング

* キーの各属性を型ごとに定められた形式でエンコーディングし、それらを属性の順に連接したもの

### boolean values

* エンコード形式
  * `true`
    * `uint_8` の `1` として格納
  * `false`
    * `uint_8` の `0` として格納

### integral numbers

* エンコード形式
  * 符号なし
    * ビッグエンディアンで格納
  * 符号あり
    * 符号ビットを反転し、ビッグエンディアンで格納

### floating point numbers

* エンコード形式
  * 下記のバイト列をビッグエンディアンで扱う
  * `> 0`
    * 符号ビットを反転したバイト列
  * `< 0`
    * すべてのビット列を反転したバイト列
  * `+0` / `-0` (負のゼロも正のゼロと同じ扱い)
    * float4: 0x80000000
    * float8: 0x8000000000000000
  * `NaN`
    * float4: 0xffc00000
    * float8: 0xfff8000000000000
  * `+Infinity`
    * float4: 0xff800000
    * float8: 0xfff0000000000000
  * `-Infinity`
    * float4: 0x007fffff
    * float8: 0x000fffffffffffff

### character strings

* エンコード形式
  * 文字列データのバイト列に既定の終端文字列を連接して格納する

### octet strings

* エンコード形式
  * 可変長 (SQL VARBINARY型に対応) 
    * 下記を連接して格納する
      * 長さを符号なし32ビット整数とし、[integral numbers](#integral-numbers) の方式で表現したもの
      * オクテットデータ列
    * ただし可変長オクテットはキーとして使用不可なので、このキーエンコーディングをそのまま使用することはなく、これをもとにした [ペイロードエンコーディング](#ペイロードエンコーディング) がペイロードの格納に使用される
  * 固定長 (SQL BINARY型に対応) 
    * オクテットデータ列をそのまま格納する

### decimal 

* エンコード形式
  * 属性のメタデータとしてprecision `p`とscale `s`が与えられる
  * 与えられた値`x`を`x = y * 10^(-s)`として表す。(`y`は符号付き整数)
  * `p`桁の符号付き整数を2の補数で表現可能な最小のオクテット数を`n`とする
  * `n`オクテットによる2の補数で表現される符号付き整数として`y`を[integral numbers](#integral-numbers)と同じ扱いで格納する

### date

* エンコード形式
  * 1970-01-01からの経過日数を符号付き64ビット整数とし、[integral numbers](#integral-numbers)と同じ扱いとする
  * 1970-01-01より前の日付は負の数で表現される

### time of day

* エンコード形式
  * 00:00:00からの経過秒数(単位ナノ秒)を符号付き64ビット整数とし、[integral numbers](#integral-numbers)と同じ扱いとする
  * 表現される時刻の範囲は[00:00:00.000000000, 23:59:59.999999999] (端点含む)
    * 簡単のために符号付きで扱うが実際には負の数は現れない

### time point

* エンコード形式
  * epoch(1970-01-01 00:00:00.000000000)からの経過秒数(単位秒)を符号付き64ビット整数、サブセカンド部分(単位ナノ秒)を符号無し32ビット整数とし、それぞれを[integral numbers](#integral-numbers)と同じ扱いでエンコードしたものを連接する
  * epochよりも前の時点を表現する場合、秒部分は負の数となる
  * サブセカンド部分は[0, 999999999]の範囲(端点含む)
 
### nullable values

* エンコード形式
  1. `uint8_t present` 
     * 値が存在するかどうか
       * `0x80` - 存在しない (*1)
       * `0x81` - 存在する (*1)
  2. `T value`
     * 実際の値 (値が存在する場合のみ)
       * key encoded value - 実際の値
     * 値が存在しない場合、`value`も存在しない

(*1) 本来 `0x00`, `0x01` で十分だが、過去実装との互換性のためにこれらの値を選んでいる 

### ascendant/descendant order

* エンコード形式
  * 昇順
    * そのまま格納する
  * 降順
    * バイト列のすべてのビットを反転して格納する

## ペイロードエンコーディング

* 本文書ではペイロードについて特定のエンコーディングは規定しない(実装依存)。
  * 比較・ソート順序に関する制約がないため、属性の値とバイト列間で効率よく相互変換できるものであれば何でも良い。
  * 現状実装ではキーエンコーディングと同じ、但しペイロードにはascendant/descendant orderの区別が無いので常にdescendantとしている
