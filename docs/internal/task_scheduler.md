# jogasaki ジョブ/タスクスケジューラ内部設計メモ

2025-03-28 kurosawa

## この文書について

jogasaki のタスクスケジューラの内部設計における主要な点や特筆すべき機能について述べる

## 概念

- タスク

  - 単一スレッドで実行可能な細粒度の処理の単位
  - `jogasaki::scheduler::flat_task` クラスで表される
  - 狭義にはjogasakiのプランスケジューラ(`dag_controller`)が実行計画上のプロセスやエクスチェンジを並列処理するために作成しスケジュールするもの
    - `flat_task` のコンストラクタで　`flat_task_kind` の `bootstrap`, `dag_events`, `wrapped` を受け取って作成されるもの
  - 広義にはDAG由来ではないタスクも含む(単純INSERT文のタスクやコミットの非同期処理に関するものなど)
    - `flat_task_kind` が `write` や `wrapped` などであるもの
    - 通常、タスクといった用語はこちらを指すことが多い
    - 特に、汎用に使用する `wrapped` タスクを本文書では「カスタムタスク」と呼ぶ

- ジョブ

  - 1個以上のタスクからなる一連の処理のまとまり
  - `jogasaki::scheduler::job_context` クラスで表される
  - ジョブはタスクの集合だが、最初から全てのタスクが出揃っているわけではなく、前段のタスクが後続のタスクの作成・スケジュールを繰り返し、全体でジョブという単位をなす
  - ジョブは必ず `teardown` 処理によって終了する。これは以下のステップを含む。
    - ジョブ配下のすべてのタスクが完了したことを待機する。実行中のタスクがある場合は `teardown` 処理を(再)スケジュールし、完了を再度チェックする
    - ジョブに関連付けられた完了コールバックを呼び出す
      - ここでクライアントへのレスポンスが送信されることが多い
    - `job_context` およびジョブに関連づいたリクエストのリソース(コールバック等)をリリースする
  - `teardown` 処理を行うための専用のタスクを `teardown` タスクと呼ぶ
    - 最適化として、 `teardown` タスクを用いず、最後の処理を行ったタスクが `teardown` 処理も合わせておこなうことがある(in-place teardown)

- リクエスト

  - SQL実行エンジンはAPI経由でSQLステートメントの実行やコミット・アボート・トランザクション開始といった処理要求を受け付ける
  - これらの要求をリクエストと呼び、`request_context` クラスで表される
  - 1リクエストは1ジョブとして実行され、ジョブとリクエストは 1対1に対応するが、下記のように観点が異なる
    - ジョブはタスクをどのようにスケジュールするかという観点を主眼とする
      - `job_context` はスレッドを排他するためのプリミティブやタスクのカウンタ等を管理する
    - リクエストはSQLの要求内容を実現することを主眼とする
      - `request_context` はステートメント情報などSQLドメインの情報を保持する
  - API要求のうち非同期処理が不要であるものもあり、そのようなケースでは `request_context` 及び　`job_context` は作成されないことが多い。
    - 詳しくは [リクエストスレッドで実行されるリクエスト](#リクエストスレッドで実行されるリクエスト) を参照

- タスクスケジューラ

  - タスクの実行を計画し、CPUリソースを割り当てて適切なタイミングで実行するもの
  - タスクスケジューラへタスクを渡して計画させる処理を「スケジュール」という
  - タスクスケジューラが適切なスレッド上でタスクを開始し完了させることを「実行」という
  - インターフェース定義は `jogasaki::scheduler::task_scheduler`
  - 実装には下記の3つがある
    - シリアルスケジューラ(`serial_task_scheduler`)
    - スティーリングスケジューラ(`stealing_task_scheduler`)
    - 上記2つを切り替えて使用可能なハイブリッドスケジューラ(`hybrid_task_scheduler`)
  - ただしハイブリッドとシリアルは性能改善のための実験的な実装である
    - 既定の構成ではスティーリングスケジューラが使われる

- トランザクションコンテキスト

  - SQL実行エンジンにおける、トランザクション状態や性質に関する情報
  - `transaction_context` クラスで表される、
  - タスクスケジューラと連携してトランザクション操作の整流化などを行う
    - [タスクスケジューラの機能参照](#タスクスケジューラの機能) を参照

## タスクスケジューラの機能

- スレッドプール

  - スレッドをプールして必要に応じてタスクにアサインして実行する
  - スレッドを最初に確保して再利用することでスレッドの開始・停止によるコストを避ける
  - 使用スレッドの個数が際限なく増えることを避ける (使用スレッド数は起動開始時から停止まで一定)
  - 各スレッドを特定のCPUコアにバインドし、コアに対する複数スレッドの取り合いを避ける
    - 既定では行わず、性能測定時に構成パラメータで設定可能

- 同一トランザクションを使用するタスクの整流化

  - CCエンジンのAPI規約を守るための機能
  - トランザクションを使用しており整流化が必要なタスク(sticky)を区別し、stickyタスクは各ワーカーごとの特殊なタスクキュー(stickyキュー)に保持する

  - トランザクションコンテキストとタスクスケジューラによって整流化を実現
    - トランザクションコンテキストが「使用するワーカーとワーカーの保持するstickyタスクの個数」を記録する
    - スケジュール時にタスクスケジューラこのカウンタを確認し、個数が 0 になるまではそのワーカーのstickyキューへ投入する

  - トランザクションの完了要求の整流化という機能もあるが、上記機能とは独立している
    - 詳しくは [concurrent_end_tx.md](https://github.com/project-tsurugi/jogasaki/blob/master/docs/internal/concurrent_end_tx.md) を参照

- スティーリングによる空きCPUコアの活用、負荷分散

  - ワーカーはローカルなタスクキュー(mainキュー、stickyキュー)にタスクが見つからなかった場合、スティーリングを試行する
  - ラウンドロビンでワーカーを順次選択し、そのmainキューを確認して、見つかったタスクをスティールする
  - 最後にスティールが成功したワーカーのインデックスを記憶しておき、その隣から順次探していく
    - 隣ではなく同じワーカーから探したほうがいいという説もある
  - スティールしたものはターゲットのキューからpopし即座に実行する(別のタスクキューにいれたりはしない)
  - スティールしたタスクの完了後は最初のルール (ローカル->スティーリングの順) に戻り処理すべきタスクを探す

- サスペンド・復帰

  - 応答性能を維持しつつ、CPUをビジーに使用するのを避けるための機能
  - ローカルなキューにもスティーリング対象のキューにも処理すべきタスクが発見できなかった場合、ワーカースレッドはサスペンドし、一定時間経過するか他のスレッドからタスクが渡されるまで復帰しない
  - 既定ではサスペンドしてから復帰までの時間は1秒 (`sql.worker_suspend_timeout` 構成パラメーター)

- 条件確認タスク

  - 軽量な条件確認部分とボディ部分からなる特殊なタスク
  - グローバルな位置に専用のタスクキューとワーカースレッド(watcherスレッド)があり、定期的にそのスレッドが起きて条件確認部分を実行し、条件が満たされる場合にそのタスクのボディ部分を実行する
  - 条件が満たされなかった場合は再度タスクキューに戻されて次の確認を待つ
  - ポーリングのような一定の時間間隔で実施する内容をもつタスクを実行するもの
  - LTXのBeginウェイト(epochの待機)はこの仕組みを使う

## スケジュールされたタスクがどのキューに保存されるか

- 通常のローカルタスク(mainタスク)
  - スケジュール処理を呼出しているスレッドに対して固定的なpreferred workerを定めそこへ渡す
    - スレッドからのスケジュール呼出が初めてだった場合は、ラウンドロビンによりpreferred workerを決定する
    - `use_preferred_worker_for_current_thread` 構成パラメータでこれをdisableすることも可能
      - その場合はスケジュール呼出ごとのラウンドロビンによりワーカーが選択される
    - ワーカースレッドのpreferred workerは自分自身
  - スケジュール時に「サスペンドされているワーカを優先的に探す」オプションも指定できる
    - この場合はサスペンドされているワーカを探してタスクを渡し、そのワーカーをサスペンド状態から復帰させる
    - 即時性が求められるときにこの指定が使用される
- stickyタスク
  - 関連するトランザクションを使う別のstickyタスクがすでにある場合、そのタスクを保持しているstickyキューに投入される
  - そのようなstickyタスクがない場合、mainタスク投入時のワーカー選択と同じロジック(上記)でワーカーを決定し、そのstickyキューに投入する
- 条件確認タスク
  - 条件確認タスクの専用のワーカーとキューがあるのでそこへスケジュールされる

## タスクスケジューラに関連するチューニングパラメータ

- `busy_worker`

  - ワーカーが処理すべきタスクがない状態が続いた際にサスペンドするか、busy waitによりタスクキューを監視し続けるか

- `use_preferred_worker_for_current_thread`

  - リクエストスレッドとワーカースレッドの対応付けを行い、同じリクエストスレッドからスケジュールされたタスクが同じワーカーに渡されるようにするか
  - `false` の場合はラウンドロビンによりワーカーが選択される

- `stealing_wait`

  - ローカルタスクキュー(main/sticky)にタスクが見つからないことが連続で何回起きたらスティーリングへ移行するか

- `task_polling_wait`

  - ワーカーが処理するタスクがなかった場合にスリープや `std::this_thread::yield()` を試行するか
  - 実験的にスリープやイールド処理を行って次のポーリングまでの間隔をあけてみるためのパラメータ
  - スリープはサスペンドと異なり、途中で起きない。指定時間まで必ず寝る。
  - あまり効果がなかったためかデフォルトでは無効になっている

- `worker_suspend_timeout`

  - サスペンド時間の長さ(us)を指定する
  - `busy_worker=false` の場合のみ有効
  - 処理するタスクが(ローカルにもスティーリング候補にも)ない場合、ワーカーは `worker_suspend_timeout` に指定された時間が経過するか、新しいタスクがワーカーにアサインされて起こされるまでサスペンドする

- `dev_thousandths_ratio_check_local_first`

  - ワーカーがローカルタスクキューにタスクがあるかどうかの確認を行う際、つぎのいずれかの順でチェックするが、その頻度を設定するもの

    - mainタスクキューをチェックしてタスクがなければstickyタスクキューをチェックする
    - stickyタスクキューをチェックしてタスクがなければmainタスクキューをチェックする
  - 既定値は 100 で、mainにくらべてstickyを10倍頻繁に確認するようにしている

## ハイブリッドスケジューラ

スティーリングスケジューラは余力のあるワーカーがタスクをワーカー間で移動させることでワーカー間の負荷分散を実現する。しかし性能面ではワーカーを移動させず、同一ワーカーが集中的にタスクを処理した方が効率がよい場合もある。これを行うのがシリアルスケジューラである。さらに、ハイブリッドスケジューラはシリアルスケジューラとスティーリングスケジューラを切り替えて要求内容の複雑さに応じてどちらで稼働させるかを決める。具体的には下記のとおり。

- SQLの種別によって「ワークロードの処理レベル(work_level)」が 0 から 60 の間の数値で決まっている
  - 詳細は `jogasaki::plan::statement_work_level_kind` を参照
- 構成パラメータ `sql.lightweight_job_level` によって「短時間で終わるジョブ」のグループを定義する
- `work_level` が `lightweight_job_level` 以下の場合は短時間で終わるジョブとしてシリアルスケジューラによって処理する
- そうでない場合はスティーリングスケジューラにスケジュールする

## リクエストがどのようなジョブ・タスクとして処理されるか

SQL実行エンジンに対するリクエストが具体的にどのようなジョブやタスクとして処理されるかを述べる

### 単純INSERT文 (values句をもつINSERT文)

  - 単独の `write` タスクとして実行される
  - ジョブの teardown 処理は in-place に実行される

### SQLステートメント/クエリ (単純INSERT文以外のDML)

  - プランスケジューラ(`dag_controller`)によって実行計画(DAG)の各ノードの状態が管理され、随時下記のタスク群が作成・スケジュールされる

    - `bootstrap` タスク
      - ステートメントの実行ジョブを開始するためのタスク
      - `dag_controller` を初期化
      - `dag_controller` による処理開始をトリガーするための内部イベントを発行し、その処理(下記 `dag_events` タスクによるものと同じ)を行う

    - `dag_events` タスク

      - `dag_controller` の処理を順次進めるための内部イベント処理を行う
        - DAGの各ノードの状態管理を行い、タスクの作成 (下記 `wrapped` タスク) やスケジュールを適宜おこなう

    - `wrapped` タスク

      - `dag_controller` がDAGの各ノードに対して作成するタスク(processやexchange処理を並列化したもの)

    - `teardown` タスク

      - ジョブの完了コールバックを呼出し、クライアントに対してSQLステートメント/クエリの完了報告を行う

### トランザクション開始処理

トランザクション開始処理のジョブの内容は下記のとおり

- 下記の一連の処理を行うカスタムタスクによってジョブが開始される
- CC に `begin` 指示を行う
- 成功したら `transaction_context` を作成し、並列hash mapに保存する
- OCCの場合、およびCCが `begin` に失敗した場合
  - すぐに `teardown` 処理に移行
  - OCCはbegin waitがないため
- LTX/RTXの場合
  - 条件確認タスクを作成してスケジュール
  - CCへトランザクションの状態を随時確認し、begin waitが完了したかを待つためのもの
  - begin waitが完了したら `teardown` 処理に移行し、トランザクション開始ジョブを終了させる

### コミット処理

- コミット処理のジョブは下記の処理を行うカスタムタスクによって開始される
  - CCにプレコミット指示を行う
    - 処理結果はCCからのコールバックによって受け取る(pre-commitコールバック)
    - CC処理が失敗だった場合、または成功かつ`commit_response = available` の場合
      - 次のカスタムタスクをスケジュールし、そのタスク内でクライアントへレスポンスを送信し、さらに `teardown` タスクをスケジュールする
        - プレコミットコールバックでは通信のような時間がかかる処理を行うべきではないため、タスクをスケジュールする
        - 実験的に、コミット成功の場合にはタスクを経由させない設定も可能 (`configuration::direct_commit_callback_=true`)
    - 成功かつ `commit_response = stored` の場合
      - CCから戻されたdurability markerを使ってdurableになるまでジョブ完了を遅延する。具体的には下記
        - `transaction_context` にdurability markerをセットする
        - durability_managerに `request_context` を渡し、ジョブの終了を下記 [永続化通知](#永続化通知) ジョブに移譲する

- コミット処理のジョブは、ジョブ完了コールバックでクライアントへレスポンスを戻すわけではない点で特殊である
  - 例えばコミット通知の設定(`sql.commit_response`) が `available` な場合、下記のような順序で処理される
    - プレコミットコールバック完了後にクライアントへレスポンスが通知される
    - CCからプレコミット呼出の制御が戻るのはそのあとのPWAL処理が終わってから
    - ジョブの `teardown` 処理はそれよりも遅れる
  - このようにプレコミットコールバック呼出とCCのプレコミット完了は非同期であり、現状実装では前者が常に先行する
  - ジョブ完了コールバックは処理内容はほぼ空で、 `request_context` の生存管理のために存在する

### 永続化通知

- データストアがあるエポックまで永続化を完了したとき、CC経由でSQL実行エンジンのdurability callbackを呼び出しdurability markerを渡して永続化境界を通知する。durability callbackはこれを受けて永続化通知を処理するジョブ (永続化通知ジョブ) をスケジュールする。このジョブは下記のような一連の処理を行うタスクとして開始される。

- データストアから永続化境界を示すdurability markerを受け取る
- すでにプレコミットを終了して永続化を待機していたコミット処理ジョブを検索し、それらの持つdurability markerとデータストアのdurability markerを比較し、永続化が完了したものをピックアップする
- ピックアップされたジョブの `request_context` ごとに下記の内容を実施するカスタムタスクを作成しスケジュールする
  - クライアントへコミット完了通知を戻す (storedへの到達を通知)
  - コミット処理ジョブを完了させる `teardown` タスクをスケジュールする
- 永続化通知ジョブを完了させる `teardown` タスクをスケジュールする

### ダンプ

- ダンプは出力チャネルがクエリと異なる (`jogasaki::executor::io::dump_channel`) のみで、基本的にクエリと同様の処理を行う
  - クエリの場合はエンドポイントのchannelからwriterを取得してそこへシリアライズした結果セットを書き出すが、`dump_channel` は parquet/arrow ファイルに出力する
  - 結果セットへはダンプしたファイルパスをレコードとして出力する

### ロード

ロードにはトランザクショナルなものと非トランザクショナルな2つの動作モードがある

- トランザクショナルロード
  - ロードを単一のトランザクション上で実行するためのもの
    - 並列化ができないため、性能には制約がある
  - ファイルローダー (`executor::file::loader`) を繰り返し呼び出すジョブによって駆動
  - このジョブはロードタスク (`flat_task_kind::load` をもつ `flat_task`) からなる
  - これはローダーを1回だけ呼び出すタスク
    - ローダーは初回の呼出でバッチサイズ(デフォルトでは10000)個のパラメータをファイルから読み出し、それを使ってステートメントを実行するジョブをスケジュールする(ステートメントとジョブは1対1対応)
    - 2回目以降の呼出では、完了したステートメントを監視して、バッチサイズに対して空きスロットがあればその個数文のステートメントをスケジュールする
  - ロードタスクはローダーの戻り値によってその完了を確認し、まだ継続中(ロード対象のデータがあるか、実行中のステートメントがある)であれば自分自身をyieldしてリスケジュールする
    - スロットに空きが発生しない間はbusy loop的にステートメントの終了を待機する形
  - ローダーが完了(またはエラーにより終了)であればロードタスクは `teardown` タスクをスケジュールする
- 非トランザクショナルロード
  - ロードを複数のトランザクション上から実行するためのもの
    - 並列化して実行するため性能向上が見込めるが、一貫性の保証は弱い
      - 例えばロード失敗時にロード途中のデータが残る
  - 非トランザクショナルロードを実行するジョブは下記からなる
    - バッチエグゼキューター (`executor::batch::batch_executor`) を初期化してロードを開始させるタスク
    - バッチエグゼキューターに起動される、ステートメントを実行するジョブ
    - `teardown` タスク
  - 詳しくは [batch executor 内部設計](https://github.com/project-tsurugi/jogasaki/blob/master/docs/internal/batch_executors.md) を参照

## リクエストスレッドで実行されるリクエスト

同期的にリクエストスレッド上で処理され、タスクやジョブとしては実行されないリクエストについて述べる

- アボート

  - トランザクションを使用中のタスクがなければリクエストスレッドからCCへアボート要求を行う
  - トランザクションを使用中のタスクがある場合は `transaction_context` へ `going-to-abort` フラグをセットし、タスクにCCへのアボート要求を移譲する
  - 詳しくは [concurrent_end_tx.md](https://github.com/project-tsurugi/jogasaki/blob/master/docs/internal/concurrent_end_tx.md) を参照

- DDL

  - テーブル定義の追加や削除などメタデータの更新
  - リクエストスレッド上の処理で唯一 `request_context` が作成されるケース

- describe table

  - テーブル定義の出力

- list tables

  - テーブル名の列挙

- prepare

  - プリペアードステートメントの作成

- dispose prepared statement

  - プリペアードステートメントの破棄

- explain

  - 実行プランの出力

- get error info

  - トランザクションのエラー情報の取得

- get transaction status

  - トランザクション状態の取得

- dispose transaction

  - トランザクションの破棄

## jogasakiの処理が行われるスレッド

  - リクエストスレッド
    - jogasaki APIを呼び出しているスレッド
      - tsurugidbとして稼働する際は、通常tateyama endpointが管理するスレッドがこれにあたる
  - ワーカースレッド
    - 通常のワーカーに1対1に対応するスレッド
    - 条件確認スレッド(watcherスレッド)
      - 条件確認タスクキューを専用に監視、実行するワーカースレッド
  - コールバックスレッド
    - CC precommit コールバックが実行されるスレッド
      - CC実装に依存するが、現実装ではSQL実行エンジンがCCを呼び出すスレッドと一致
    - durability コールバックが実行されるスレッド
      - データストア実装に依存するが、現実装ではSQL実行エンジンがCC経由でデータストアを呼び出すスレッドと一致

## 制限事項・注意点

- タスクスケジューラが使用している `tbb::concurrent_queue` はpopする以外の方法で複数スレッドから安全に内容を確認する機能(peek)がない。
  - キュー内の要素の個数も取得不可なため、「比較的空いているキューにタスクを投入する」といったことができない
