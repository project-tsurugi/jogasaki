# DDLとDMLの同時実行の制御について

2025-06-26 kurosawa

## 本文書について

tsurugiに対してDDLとDMLを混在して実行した場合の仕様が明確でなく、排他制御の実装も不十分だった。この問題を解決するための設計について記述する。

## 用語

- DML
  - SELECT
  - INSERT
  - UPDATE
  - DELETE

- DDL 
  - CREATE/DROP TABLE
  - CREATE/DROP INDEX

- ステートメント
  - DMLまたはDDLの一文

- クエリ
  - SELECT文のみからなるステートメント
  - リザルトセットをもつ
  - INSERT ... SELECTは含まない

- リクエスト
  - SQL実行エンジンに送信する処理要求の単位
  - ステートメントの実行はリクエストとして要求される
  - ステートメント以外のリクエストもある
    - begin/commit, prepare, describe tableなど

## 外部仕様

### テーブル閉塞

原則としてテーブルに対するアクセスを閉塞することにより、DDLとDMLの実行可能区間を分離する

- 操作対象のテーブルに関連づいた(共有)ロックを取得し、取得できた場合のみ実行するというモデル
  - DDLは対象テーブルに対する排他ロックを取得し、トランザクションの完了まで保持する
  - DMLは対象テーブルに対する共有ロックを取得し、ステートメントの完了まで保持する
  - 共通のテーブルを操作対象として持たないステートメント同士は排他されず、それぞれ独立して実行可能
- DMLの実行区間ではDDLを開始できない
  - DMLはステートメントの開始時にテーブルに対する共有ロックを取得する
  - 共有ロックは複数のDMLが同時に取得可能なのでDML同士は並列に実行可能
  - DDLは排他ロックが必要なのでDMLステートメントが完了するまでは取得できない
- DDLを実行したトランザクションが完了するまではDMLは開始できない
  - DDLはそのトランザクションにおいて最初に実行された際に操作対象のテーブルに対する排他ロックを取得する
  - トランザクションがコミット(shiarkami precommit)かアボートするまでこのロックは保持される
  - 同一トランザクションでDDLが2回以上実行された場合、初回に取得したものと同じ排他ロックを使用する
    - 操作対象のテーブルが実行ごとに異なる場合、排他ロックは同じものを使い、そのロック対象を拡張する
  - 同一トランザクションでDDL実行後にDMLが実行された場合、DMLは排他ロックを親とする共有ロックを取得する
    - この共有ロックを保持するDMLは親が排他ロックしているテーブルに対してもアクセス可能
    - 共有ロック自体はDMLステートメントの完了時に開放。排他ロックはトランザクション完了まで保持される。
- DDL同士の場合、先にDDLを実行したTXが排他ロックを持ち、そのトランザクションの終了後まで別トランザクションのDDLは開始できない
  - 同一トランザクションを使った複数のDDLが並行するケースは考慮外
    - 将来的にはDDLをstickyタスクにすることで対応予定
- DDL/DMLいずれの場合も、ロックが取得できない場合はエラーが戻される。なんらかの処理を待機することはしない
  - 将来的には待機を検討するかもしれない

## 1.5での制限事項

- DDLはCREATE TABLE/DROP TABLEのみをサポート
  - CREATE INDEX/DROP INDEXも本文書の排他処理の対象だが1.5では未実装

## post-1.5 で対応予定のトピック

カッコ内はtsurugi-issuesのissue番号

- DDL/DML混在問題の残り (#177, #1137)
  - トランザクションによって使用されたテーブルをコミット前に別トランザクションからDROPするとshirakamiがクラッシュ
- DDL処理を行ったトランザクションをアボートするとシステムテーブルにゴミが残ったり不整合な状況になる (#448)
  - トランザクションアボート時に補償トランザクションを実行し不整合を修正する
  - DDLをロールバック可能にするわけではないが、補償トランザクションの内容によってはロールバックされたかのように見えるケースもある
- Prepared statementを保持したままテーブルを再作成してアクセスすると不安定な状態になる(#702)
  - DDL実行時にprepared statementを使用不可としてマークし、使用した際にはエラーにする
- truncate文 (#812) alter table rename文 (#1089)
  - 内部的な名前/IDのマッピング変更により対応

## 細かい注意点

- CREATE TABLEはその処理中にロック対象を作成する、またDROP TABLEは処理中にロック対象を削除することになる
  - ロックが有効なのはこれらの作成から削除までの間
  - トランザクションが未完了な時点でも、削除されたテーブルに対するロックは自動的に開放される
- ステートメントの実行区間(開始から完了)はSQL実行エンジンが定義するもので、クライアントから観察されるものと少し異なることがある
  - INSERT/UPDATE等のリザルトセットを持たないDMLステートメントはその処理が完了するまで
    - クライアントが観察する実行区間とほぼ一致
  - クエリはSQL実行エンジンんが結果セットをエンドポイントに渡し終え、完了通知を送った時点で完了
    - クライアントがそれを読み出したかどうかは関係ない

## 内部設計

TBD