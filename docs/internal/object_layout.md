# オブジェクトレイアウトにおけるfalse sharing対策

2025-05-02 kurosawa

## 本文書について

false sharingを避けるためにC++のオブジェクトレイアウトをどう設計すべきか、特にメンバ変数をどのように配置するべきかに関するおおまかな指針を記述する

## 背景知識

- x86_64ではキャッシュラインが64バイトであり、この境界内に無関係な複数のスレッドが読み書きを行った場合はfalse sharingが発生し性能低下の原因になる
- 無関係でない意図的なもの、例えばアトミック変数を複数スレッドが共有して読み書きするようなケースは本書の範囲外 (true sharing)
- false sharingの対策として、複数のスレッドがアクセスする変数をアラインして同一キャッシュラインに乗らないようにする
- しかしアラインをするとデータメンバの分布が疎になり、空間効率が悪化してキャッシュ効率が悪化するため、適度にバランスを取る必要がある

## 対象となるオブジェクト

- 頻度の高い書き込みが発生するメンバ変数を持つクラスや構造体
- またはsub-objectとしてしてそのようなものを持つもの

## 原則

- 書き込みが発生するメンバ変数と読み込みしかないメンバ変数を分離する
  - 例えばread-onlyな変数を上の方(アドレスの小さい方)に配置、write-mostlyな変数を下の方(アドレスの大きい方)に配置する
- write-mostlyな変数のうち先頭のものを64バイトでアラインする
  - (64バイトを超えるまでは)後続のwrite-mostly変数は同一のキャッシュラインに乗る
  - write-mostlyな変数をまとめて構造体にし、それに対してアラインメントを指定するとグルーピングの意図がより明確になる

## implication

これを実施することで対象オブジェクトは下記のような アライメントとサイズを持つことになる

- オブジェクト全体も64バイトでアラインすることになる
  - メンバーのアラインメント要求のうち最大のものがオブジェクト全体のアラインメント要求になるため
- オブジェクトのサイズは64バイトの倍数になる
- 書き込みデータメンバの直前にはパディングが発生しうる
- 末尾にもパディングが発生する

## 注意事項

- write-mostlyな変数を上の方に置く案もあるが、深く探求していない
- サイズが小さいほうがキャッシュに配置するうえで有利だが、本文書ではサイズを小さくする方向は追求しない
- C++非標準な機能( `#pack` など) を使うとより細かい制御も可能だが、本文書の範囲外
-











