# variable length buffer resource lifecycle

## 本文書について

可変長バッファ (varlen. buffer) の使用方法について開発者間で情報共有するためのメモ

## 可変長バッファとは

- `CHAR`, `VARCHAR`, `BINARY`, `VARBINARY` などのデータ型は可変長であり、1フィールドに含まれるデータの長さは一定していない。一方で、レコード領域( `accessor::record_ref` の指し示す領域 ) において1レコードが占める領域は固定長である。そこで可変長データ型を扱う際には、可変長バッファ(varlen. buffer)という領域を確保してデータ本体を格納し、レコードのフィールドにはそこへのポインタを格納する。

- `accessor::text` および `accessor::binary` が可変長データのレコードフィールドに用いられるオブジェクトである。SSO (Short String Optimization) により、短いデータ(15バイト以下)の場合には、データを直接レコードフィールドに格納する。一方、長いデータの場合には、データ本体を可変長バッファに格納し、レコードフィールドには可変長バッファへのポインタを格納する。
  - このためこれらのデータ型に対しては短いデータと長いデータの両方で動作確認を行うことが重要である

## ステップ間でのデータの受け渡し

- 可変長バッファはレコードのデータの一部を保持するものであるため、上流から下流へレコードデータが受け渡されるのに従って可変長バッファの内容も渡される必要がある。ただし、この際に必ずしもデータコピーが必要になるとは限らない。例えば同一プロセス内でレコードのコピーが発生したとしてもコピーもとのレコードとコピー先のレコードの生存区間が一緒であれば、それらはvarlen. buffer内の同一のメモリ領域を参照してよい。

- プロセスはスレッド間での待ち合わせを必要としない処理であり、エクスチェンジはその境界に配置される。そのため原則的にエクスチェンジでは待ち合わせやデータ交換が必要になるので、エクスチェンジへプロセスがデータを送出(`record_writer`の`write`操作)する際にはデータのコピーが必要になる。varlen. bufferのデータもプロセスのvarlen. bufferからエクスチェンジのvarlen. bufferへコピーする。

- 逆に、プロセスがエクスチェンジのデータを読み出し(`record_reader`または`group_reader`の`read`操作)ながら駆動する際は、エクスチェンジの保持する領域をプロセスが参照する。エクスチェンジはプロセスによって 読み出された単位(レコード or グループ)でその領域を解放することができる。(ただしこのような粒度でエクスチェンジ領域を解放するロジックは2024-09現在未実装であり、エクスチェンジは同期型で動作している。varlen. bufferのデータもエクスチェンジに一括して保持されてまとめて解放される。)

## 可変長バッファの実装

### エクスチェンジ

#### 同期型

groupやaggregateのような同期型のエクスチェンジの場合は、`monotonic_paged_memory_resource` によって確保されたメモリ領域を使用する。同期型エクスチェンジの処理では部分的に使用するメモリ領域を解放する必要はないため、可変長のデータを効率よく保持して一括で解放できる機能があれば十分である。

#### インクリメンタル型

(2024-09現在はforwardも同期型で実装されている)

forwardはレコードを到達順 (FIFO order) にインクリメンタルに処理するエクスチェンジである。forward内部で保持するレコードに対するvarlen. bufferは `fifo_paged_memory_resource` を使用して実装する。エクスチェンジへ到達順にレコードが下流に送出されるため、その順序で送出済みのレコードに対する領域を解放することが求められるためである。

### プロセス

プロセスでは `lifo_paged_memory_resource` を使用してvarlen. bufferを実装する。プロセス処理ではトップレベルの関係演算子によってそのプロセスが処理するレコードやグループの単位が決まる。上流の関係演算子が処理した内容を下流が受け取って処理するため、下流が使用中は上流側でメモリを解放することはできない。トップ関係演算子が送出する単位(レコード or グループ)の処理が終わった時点ではそれまでに使用したvarlen buffer領域は参照されなくなるので解放することができる。

`utils::checkpoint_holder` によって、開始時点のlifo_paged_memory_resourceの状態を記録し、スコープの終了時点でその状態に戻すことができる。

プロセスのトップレベル関係演算子はこの機能を利用して、送出単位ごとにvarlen. bufferをrewindして不必要になった領域を再利用する。送出単位の境界を超えてvarlen. bufferをrewindしてしまうと、下流の関係演算子が参照している領域が解放されてしまうため、メモリ破壊につながる( https://github.com/project-tsurugi/tsurugi-issues/issues/946 )。この場合メモリページ自体は `memory::page_pool`によって確保されているため、ASANによって検出されず発見しにくいバグとなる。

## evaluatorと可変長バッファ

evaluatorは式の評価の途中でvarlen dataを生成して使用する必要がある際に、varlen bufferを作成してそこへの参照を`any`に入れて戻すことがある。そのため、evaluatorが評価結果を`any`によって戻す際、その`any`にvarlen bufferへの参照が含まれる可能性がある。

evaluator側ではvarlen bufferをrewindすることができないため、evaluatorを呼び出した側で結果を使用した後（その`any`が完全に不要になった後）にvarlen bufferをrewindする必要がある。

なお、`any`を戻さない式評価の場合はこの限りではない。例えば`evaluator::evaluate_bool`はその内部でrewindする機構を持っている。
