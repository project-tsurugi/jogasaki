# プライマリ・セカンダリインデックスのサロゲートIDの導入

2025-11-19 kurosawa

## 本文書について

本文書は本リリース(1.8)で導入予定のインデックスのサロゲートIDに関する設計を記述する

## 用語

- サロゲートID(index surrogate ID): 本リリース以降で新規作成されるインデックスに対して導入される、インデックスの実体を一意に識別するために使用する整数(符号無64ビット)。これまではインデックス名がキーであるようにしていたが、インデックス名は変更されるため不変なサロゲートIDを導入する
- ストレージキー(storage key): sharksfin/shirakami のAPI上で、ストレージを一意に特定するために使用するバイナリ列
- ストレージID(storage ID): shirakamiが用いる、ストレージを一意に識別する符号無64ビット整数 ( `shirakami::Storage` ) 
  - limestoneにも渡されて永続化される

## 背景

- jogasakiのテーブルは1個のプライマリインデックス、0個以上のセカンダリインデックスで構成される
- プライマリインデックスはテーブルと同一の名前を持ち、セカンダリインデックスはCREATE INDEX文で指定された名前を持つ
- インデックスはプライマリ・セカンダリいずれもsharksfin/shirakamiのストレージにマッピングされる
- ストレージの特定にはストレージキーが使用される
- ストレージキーには任意のバイナリ列を使用可能だが、*既存のjogasakiの実装ではインデックス名を使用していた*
- このためインデックス名(テーブル名でもあることも多い)とストレージの対応は1:1に固定されてしまい、下記のような問題により新規機能の実装が困難になっている
  - ALTER TABLEでSQL上のテーブル名が変更されると、テーブル名・インデックス名とストレージキーが乖離してしまう
  - TRUNCATE TABLEの実装にあたって、テーブル名を維持しつつ背後のストレージを再作成するという方式を実施したいが、テーブル名とストレージキーが1:1のために対応できない
  - DROP TABLEにおいて、テーブルとストレージの削除のタイミングを分離し、ストレージ削除を遅延させたいという要求がある。しかしDROP TABLE 直後に同名でCREATE TABLEが実行されるとストレージキーが衝突するためCREATE TABLEが失敗してしまう
- これらの問題を解決するために、インデックス名とは別のサロゲートIDを新規作成のインデックスに割当て、それをストレージキーとして使用する
  - 既存のインデックスは引き続き作成時のインデックス名をストレージキーとして使用することで後方互換性を維持する

## 設計方針

- jogasakiにインデックスのサロゲートID(index surrogate ID)の概念を導入する
  - サロゲートIDは本リリース以降で作成される新規インデックスに対して一意に割り当てられる符号無64ビット整数
- jogasakiがsharksfin/shirakami APIを呼び出す際のストレージキーを下記のように変更する
  - サロゲートIDを持つ場合は、そのサロゲートIDをbig-endianのバイナリ列に変換したものをストレージキーとして使用する
  - サロゲートIDを持たない場合(既存のインデックス)は、従来通り(作成時の)インデックス名をストレージキーとして使用する
  - システムテーブル(現行では `__system_sequences` テーブルのみ)は既存の状態を維持する。つまりサロゲートIDは割り当てず、インデックス名をストレージキーとして使用する
    - システムテーブルのメタデータが複数のバージョン混在すると混乱を招くため

## jogasakiのメタデータ

jogasakiはインデックスのメタデータを `storage.proto` の `IndexDefinition` 定義に基づいてシリアライズし、ストレージオプションとしてsharksfin/shirakamiのストレージに保存して永続化している。
インメモリではこの内容を `yugawara::storage::basic_configurable_provider` クラスのような形で保持しており、永続化メタデータに対する更新は適切なタイミングでインメモリ上のデータ構造に反映する必要があるが、本文書では永続化メタデータを主に扱い、インメモリの詳細はここでは省略する。

### jogasakiのメタデータの変更点

- `storage.proto` の `IndexDefinition` メッセージにストレージキー用のフィールド `storage_key` を下記のように追加する

  ```
  // the definition of indices.
  message IndexDefinition {
      ...
      ...

      // the optional storage key.
      oneof storage_key_optional {
          // the index storage key.
          bytes storage_key = 25;
      }

      ...
      ...
  }
  ```

  - 1.8以降のリリースで `IndexDefinition` が新規に作成される際にはこのフィールドにサロゲートIDをbig-endianのバイト列として保存する
  - 既存のインデックスにはこのフィールドは存在せず、jogasakiは既存の名前( `IndexDefinition.name.element_name` )をストレージキーとして使用する
  - 既存のインデックスに対して、このフィールドを追加するマイグレーションは自動的には行わないが、1.8以降のリリースでメタデータが更新される場合このフィールドが付加されることがある(詳細は下記参照)。
    - その際、サロゲートIDとインデックス名を両方格納可能なように `storage_key` フィールドは `bytes` 型として定義する

### `storage_key` フィールドの存在の有無とその内容

システムテーブルのインデックスについては `storage_key` フィールドは存在せず、インデックス名をストレージキーとして使用する

ユーザー作成のインデックス(プライマリ・セカンダリ)における `storage_key` フィールドの存在・非存在とその内容は下記のようになる

#### 作成リリースによる違い

- インデックスが作成されたリリースが1.8以降である場合
  - `storage_key` フィールドは存在し、サロゲートID(のbig-endianのバイナリ列)を保持
- インデックスが作成されたリリースが1.8より前である場合
  - リリース1.8以降でメタデータ更新操作がされていない場合
    - `storage_key` フィールドは存在しない
  - リリース1.8以降でメタデータ更新操作がされた場合
    - `storage_key` フィールドの有無は更新操作の種類に依存する(下記参照)

#### メタデータ更新操作

`ALTER`/`TRUNCATE`/`GRANT`/`REVOKE` 等のステートメントはプライマリ・セカンダリインデックスのメタデータ更新を伴う。これらの操作を「メタデータ更新操作」と呼び、更新処理として必要な場合にのみ `storage_key` フィールドの追加・変更を行う。

リリース1.8以降でメタデータ更新操作があった場合の `storage_key` フィールドの取扱いは下記の通り

  - `ALTER TABLE RENAME`/`ALTER INDEX RENAME`
    - すでに `storage_key` フィールドが存在する場合は、そのままの値が維持される
    - そうでない場合は `storage_key` フィールドが追加され、変更前のインデックス名を保持する
  - `TRUNCATE`
    - 新規にストレージが作成され、それに伴って新規のサロゲートIDが採番される。その内容を `storage_key` フィールドに保持する
  - `GRANT`/`REVOKE`
    - メタデータの更新を伴うがストレージキーは変更されないため、 `storage_key` フィールドは存在の有無を含めそのまま維持される

## jogasakiの実装詳細

- `storage_manager` がインデックス名からエントリーID、そしてエントリーIDから `storage_control` へのマップを保持している。これを用いて必要に応じてインデックス名からストレージキーを取得できるようにする
  - `add_entry` 関数に `std::optional<std::string_view> storage_key` を追加し、ストレージキーを呼び出し側が渡すようにする
  - `storage_control` に `std::optional<std::string> storage_key_` メンバを追加し、インデックスのストレージキーを保持する
    - 起動時処理において、 `IndexDefinition` メッセージの `storage_key` フィールドを読み取り、存在する場合はそれを使う
    - `storage_key` フィールドが存在しない場合は `std::nullopt` を格納する
- これまではプライマリインデックスのエントリのみを `storage_manager` に登録していたが、セカンダリインデックスも登録するように変更する
  - プライマリとセカンダリ両方のエントリをストレージキーの保持のために使用する
  - 権限の操作、およびDDL/DML競合防止のためのロック操作はこれまで通りプライマリインデックスのエントリのみを使用する
- create table/create index文の実装を変更し、新規にインデックスが作成される際に一意なサロゲートIDを生成し、 `IndexDefinition.storage_key` フィールドに設定する
  - サロゲートIDは全インデックスに対して一意である必要があるため、`storage_manager` に生成させる。
    - アトミックカウンタによるインクリメント
    - 起動時に既存インデックスのサロゲートIDの最大値を調べておき、そこからインクリメントを開始する
      - 既存インデックスに `storage_key` フィールドが存在し、それが下記の条件を満たす場合は、その値をサロゲートIDとして解釈し、最大値の計算に使用する
        - バイト列の長さがちょうど8バイト
        - 先頭バイトが `0x00` である

- jogasakiがsharksfin/shirakamiのストレージを操作する際に、上記で覚えておいたストレージキーを使用するように変更する
  - 関係演算子はインデックス名を保持し、必要に応じて `kvs::database::get_storage()` で操作対象のストレージを取得していた
  - `utils::get_storage_by_index_name(std::string_view index_name) -> std::unique_ptr<storage>` 関数を導入して `kvs::database::get_storage()` の代わりに使う
    - インデックス名から `storage_manager` 経由でストレージキーを取得し、それを使って `kvs::database::get_storage()` を行うもの
  - 関係演算子の作成時点でインデックス名のかわりにストレージキーを保持することも検討したが変更量が多いため避けた
  - ログメッセージ等でインデックス名を表示する必要がある場合のために `storage_manager` にストレージキーからインデックス名を逆引きできる関数も用意する

## 付録

### 新規機能対応の概要

本設計にもとづいて、新規機能の対応方針の概要を示す。本設計が有効であることを確認するための紹介であり概略にとどめる。

#### ALTER

- `ALTER TABLE RENAME`/`ALTER INDEX RENAME` によるテーブル名やインデックス名の変更時には名前(`IndexDefinition.name.element_name`フィールド)のみを更新し、 `storage_key` フィールドは変更しない
  - ただし `storage_key` フィールドが存在しないインデックスに対して実行された場合には、 `storage_key` フィールドを追加し変更前の名前をそこにコピーする
- `storage.proto` 内ではインデックスのテーブルへの依存関係が名前ベース (`StorageName`) で記録されているので、それらも変更する。この処理ではストレージキーは関与せず、そのまま維持される。

#### TRUNCATE TABLE

- `TRUNCATE TABLE` は下記のようにストレージの再作成を行うことで、テーブルを構成するプライマリ・セカンダリインデックスを初期化する
  - 新規にサロゲートIDを採番する
  - そのサロゲートID(をbig-endianバイナリ列に変換したもの)をストレージキーとしてsharksfin/shirakamiのストレージ作成APIを使用して新規ストレージを作成
  - プライマリインデックスの `storage_key` フィールドを書き換えて(存在しない場合は追加)、新規に作成したストレージキーに更新する
  - セカンダリインデックスについても同様にストレージを新規に作成し `storage_key` フィールドを書き換える
- 既存のストレージの削除は遅延させ、適当なタイミングで実施する (下記DROP TABLEと同様)

#### DROP TABLEの遅延ストレージ削除

- DROP TABLE実行時にはjogasakiのメタデータからテーブル・インデックス情報を削除するが、対応するsharksfin/shirakamiのストレージは即座には削除しないようにする方針である
- 本設計により、 DROP TABLE後にすぐ同名でCREATE TABLEが実行された場合も、ストレージキーは新規に生成された一意なサロゲートIDを使用するため衝突しない
- TRUNCATE TABLEはDROP TABLE + CREATE TABLEの処理とほとんど同じになる。違いはDROP TABLEはセカンダリインデックスをカスケードで削除してしまうので CREATE INDEXを別途行う必要があるが、TRUNCATE TABLEはセカンダリインデックスの定義を維持する
