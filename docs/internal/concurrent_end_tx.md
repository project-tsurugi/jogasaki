# トランザクション終了要求の並行処理

## 本文書について

本文書は、Tsurugi の SQL 実行エンジン jogasaki におけるトランザクション終了要求を並行に安全に処理するための設計仕様を定義する

## 背景と目的

### 現状の課題

- shirakami APIには「1トランザクションに対して同時に API を呼び出せるのは1スレッドのみ」という制約があるが、トランザクション終了処理 ( コミット/アボート ) APIの処理はこれを守れておらず、予期しない挙動につながるリスクがある
  - 現在の jogasaki は、クリーンアップに伴うトランザクションのアボート処理やクライアントからのアボート要求をカレントスレッドで即座に実行しようとする
    - 以前はshirakamiの仕様でabortだけは例外的にマルチスレッド呼出可能としていたため
  - RTX scan分割の開発においてトランザクションを使用するnon-stickyなタスクが導入され、それらとコミット処理が並列して実行される可能性が生じた

### 目的

本設計の目的は、jogasaki のトランザクション終了処理を修正し、shirakami の制約を守りながら、マルチスレッド環境で安全かつ効率的にトランザクションを終了できるようにすることである

## トランザクション終了処理の並行化

### 概要

- トランザクションの管理オブジェクト ( `jogasaki::transaction_context` ) にアトミック変数を1つ追加し、下記をアトミックに読み書きできるようにする
  - 「コミット予定か」を示すフラグ ( `going_to_commit` )
  - 「アボート予定か」を示すフラグ ( `going_to_abort` )
  - 実行中のタスクの個数 ( `task_use_count` )

- トランザクションの終了要求が発生しても、トランザクション使用中のタスクが存在する場合は終了処理はすぐには実行しない
  - アボート要求の場合、shirakami をすぐには呼び出さず、フラグを設定して終了処理を遅延させる
  - コミット要求の場合、エラーを戻す ( `RestrictedOperationException` )

- タスクの終了時点で `task_use_count` とフラグをチェックし、トランザクションを使用する最後のタスクの完了であった場合に shirakami のアボート関数 ( `shirakami::abort` ) を呼び出す

- 割り込まれたSQL処理はエラーで戻る ( `InactiveTransactionException` )

### 詳細

#### イントランザクション (in-transaction) なタスク・操作

- トランザクションと関連づいた操作のうち、トランザクション本体の制御以外の操作を **イントランザクションな操作** と呼ぶ
  - 具体的には、CC への API 呼出でトランザクションに関連づいたものであって、commit/abort要求以外のもの 
- イントランザクションな操作を1つ以上実行する可能性のあるタスクを **イントランザクションなタスク** と呼ぶ
  - 例: 一個以上の `scan`, `find`, `join_find`, `join_scan`, `write` 演算子を含むプロセスを実行するタスク

#### `transaction_context` における状態管理

- `task_use_count`
  - このトランザクションを使用している実行中のイントランザクショナルなタスクの数
  - 以下のタイミングで増減される。
    - インクリメント: ワーカーがタスクの実行を開始する直前
    - デクリメント: ワーカーがタスクの実行を完了した時点
- `going_to_commit` / `going_to_abort`
  - コミット要求またはアボート要求を受理し、進行中であることを示すフラグ
  - 一旦 `true` になったものが `false` に戻ることはない
  - 両方が `true` になることもない

#### 処理フロー

##### アボート要求時の処理

1. クライアントまたは jogasaki 内部からのアボート要求が発生した場合、対象の `transaction_context` の `going_to_abort` / `going_to_commit` / `task_use_count` を読み出す。
2. フラグのいずれかが `true` の場合はすでに終了処理が開始されているので、何もせずアボート要求は完了する (エラーにしない。アボート要求は成功・失敗の情報をもどさない) 。
3. ここまででアボート要求の受付が確定 ( [tx-state.md] の `going-to-abort` 状態へ遷移 ) 。1のアトミック操作の一環で、`going_to_abort` フラグを立ててCASで更新する。
4. ステップ 1 で読み出していた `task_use_count` を確認する。
5. もし `task_use_count` が 0 であれば、トランザクションを使用中のタスクは存在しないため、現在のスレッドで即座に `shirakami::abort()` API を呼び出す。
6. もし `task_use_count` が 0 より大きければ、使用中のタスクが存在するため、`shirakami::abort()` の呼び出しは行わず、フラグ設定に留める（アボート処理はタスク終了時に遅延される）。

##### コミット要求時の処理

1. クライアントからのコミット要求が発生した場合、commit実行を行うためにイントランザクションでないタスク (non-sticky) を作成してスケジュールする。そのタスクの内容は下記。
2. 対象の `transaction_context` の `going_to_abort` / `going_to_commit` / `task_use_count` を読み出す。
3. フラグのいずれかが `true` の場合はすでに終了処理が開始されているので呼出側に適切な通知 (inactive transactionエラー) を行って要求された処理は完了する
4. ステップ 2 で読み出していた `task_use_count` を確認する。
5. `task_use_count` が 0 より大きければ、トランザクションは使用中のため、コミットの要求タイミングが不正である。禁止された操作を行ったというエラー ( `RestrictedOperationException` ) を戻す。トランザクションは下記のようにアボートさせる。
    - ステップ 2 のアトミック操作の一環で、 `going_to_abort` フラグを立ててCASで更新する。( [tx-state.md] の `going-to-abort` 状態へ遷移)
    - [アボート要求時の処理](#アボート要求時の処理) と同様にアボート処理はタスクの終了時へ遅延させる
6. `task_use_count` が 0 であれば、ここまででコミット要求の受付が確定 ( [tx-state.md] の `going-to-commit` 状態へ遷移 ) 。 ステップ 2 のアトミック操作の一環で、 `going_to_commit` フラグを立ててCASで更新する (トランザクションを閉塞)。
7. `shirakami::commit` の呼び出しを行い、結果を呼出し側へ戻す。

##### タスク実行開始時の処理

1. ワーカースレッドがイントランザクショナルなタスクを実行しようとする際、まず対象 `transaction_context` の `going_to_commit` / `going_to_abort` フラグを確認する。
2. いずれかのフラグが `true` の場合
    - タスクの実行を開始しない。
    - タスクが含むリクエストコンテキスト ( `jogasaki::request_context` ) にエラー情報が含まれていない場合、下記をエラー情報としてクライアントへ戻す
        - エラーコード: `InactiveTransactionException`
        - エラーメッセージ: トランザクションの終了によりリクエストは中断された
    - エラー情報がリクエストコンテキストに含まれている場合、すでに発生したエラーのクリーンアップとして実施されているので、そのエラー情報をクライアントへ戻す
    - ワーカーは次のタスクの処理に移る
3. フラグが両方とも `false` の場合:
    - `task_use_count` をインクリメントする
    - タスクの実行を開始する
      
注: コミット要求を処理するタスクはイントランザクションでないので本セクションの処理の対象外

##### タスク終了時の処理

1. ワーカースレッドがイントランザクショナルなタスクの実行を完了した場合、対象 `transaction_context` の `task_use_count` をデクリメントする。
2. 同時にアトミック操作の一環として、以下の条件を評価する。
   - デクリメント後の `task_use_count` が 0 である
   - かつ、 `going_to_abort` フラグが `true` である。
3. 上記の条件を両方満たす場合、そのタスクを実行したワーカースレッドが `shirakami::abort()` API を呼び出す。これにより、遅延されていたアボート処理が安全に実行される。

注: コミット要求を処理するタスクはイントランザクションでないので本セクションの処理の対象外

## その他・注意事項

- 既存の sticky タスクのワーカーへの割り当て（整流）とそれに関連するカウンタ管理は、本設計とは独立しており、既存の仕組みが維持される。

- コミットを処理するタスクは既存のコードでは sticky タスクであったが、今回の変更で non-sticky タスクに変更 (任意のワーカーで実行可能)

- sticky タスクはイントランザクションなタスクだが、逆は正しくない (RTXスキャンのタスクはイントランザクションだが non-sticky )

- jogasakiへのアボート要求の失敗は他のトランザクション終了要求が先行した場合にのみ発生し、それ以外の理由では発生しない
  - ただし失敗した場合でも、アボート要求に対するエラーとしては通知されない
  - アボート要求は複数回実行してもよく、その効果は変わらない (冪等)

- jogasakiが内部で開始し使用するようなトランザクション (起動時のシステムテーブルの読取り等) は並行で使われないため本文書の範囲外とする

- `shirakami::abort` は他のトランザクションを待つことがほぼないという想定のもと、リクエストスレッドでの実行も可能としている
  - OCCについてはこれは正しそうだが、RTX/LTXについてはグローバルな領域のミューテックスで排他している部分があり予期せず処理に時間がかかるということがあるかもしれない
  - これが問題になる場合は、アボート呼出しもリクエストスレッドで実行ではなくnon-stickyな(イントランザクションでない)タスクとしてスケジュールするのがよい

- アボート処理とトランザクションハンドル破棄の関連
  - SQLクライアント側へアボート完了が早めに戻るようになるため、内部のアボート処理がすべて完了する前にクライアントからdispose transactionの呼出が行われる可能性がある
  - この場合でもタスクの末尾で `shirakami::abort` を呼ぶようなタイミングではまだSQL処理が途中のため、 `transaction_context` が破棄済みであるといった状況にはならない
    - jogasakiはハンドルと `shared_ptr<transaction_context>` を内部のマップで管理しており、dispose呼出はこのマップからエントリを除去する操作
    - `shared_ptr<transaction_context>` は `request_context` にも保持されており、これはSQL処理が完了するまで廃棄されない

## リファレンス

[tx-state.md]:https://github.com/project-tsurugi/jogasaki/blob/master/docs/internal/tx-state.md
[tx-state.md] 